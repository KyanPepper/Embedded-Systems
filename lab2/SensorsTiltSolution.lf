/**
 * SensorsTiltSolution.lf — Lab 2 main program.
 *
 * ── WHAT THIS PROGRAM DOES ──────────────────────────────────────────────────────
 * Reads the Pololu 3pi+ 2040 robot's built-in accelerometer (LSM6DSO IMU) every
 * 100 ms, converts the raw X/Y/Z acceleration readings into human-readable tilt
 * angles (pitch and roll), and displays all four values on the robot's LCD screen.
 *
 *   LCD line 0 → Pitch angle  (nose-up/down),  degrees
 *   LCD line 1 → Roll  angle  (left/right lean), degrees
 *   LCD line 2 → Raw X acceleration in g's
 *   LCD line 3 → Raw Y acceleration in g's
 *
 * ── REACTOR GRAPH ───────────────────────────────────────────────────────────────
 *
 *   timer(100 ms)
 *        │ trigger
 *        ▼
 *   [Accelerometer]  ──x,y,z──▶  [Tilt]  ──pitch,roll──▶  [Display]
 *        │                                                      ▲
 *        └─────────────────── a.x, a.y ────────────────────────┘
 *
 *   Every 100 ms the timer fires, triggering the Accelerometer reactor to read
 *   hardware. The raw values flow into the Tilt reactor which computes angles.
 *   Both the computed angles and the raw values are written to the display.
 *
 * ── BUILD & FLASH ───────────────────────────────────────────────────────────────
 *   $ cd lab2
 *   $ lfc SensorsTiltSolution.lf          # compile LF → C → ELF
 *   $ picotool load -x bin/SensorsTiltSolution.elf   # flash (robot in BOOTSEL mode)
 *
 * @author Kyan Kotschevar-Smead
 */

// ── TARGET DECLARATION ──────────────────────────────────────────────────────────
// Specifies the compilation target. "rp2040" is the RP2040 microcontroller on the
// Pololu robot. single-threaded tells the LF runtime to run all reactions in a
// single thread — appropriate for bare-metal embedded without an RTOS.
target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

// ── IMPORTS ─────────────────────────────────────────────────────────────────────
// Import three library reactors. Each file defines one or more reactor classes
// that we instantiate below. LF resolves paths relative to this file.

// Accelerometer reactor: on trigger input, reads the LSM6DSO over I2C and
// outputs x, y, z acceleration in g's (floats, range ±2 g at default settings).
import Accelerometer from "lib/IMU.lf"

// Display reactor: receives up to 4 string inputs and renders them on the
// 128×64 LCD using the 8×16 pixel font (gives exactly 4 lines of text).
import Display from "lib/Display.lf"

// Tilt reactor (our implementation): converts x, y, z accelerations into
// pitch (nose tilt) and roll (side lean) angles in degrees.
import Tilt from "lib/Tilt.lf"

// ── MAIN REACTOR ─────────────────────────────────────────────────────────────────
// In Lingua Franca every program has exactly one "main" reactor — the top-level
// composition. It instantiates other reactors and wires them together.
main reactor {

  // ── REACTOR INSTANCES ────────────────────────────────────────────────────
  // Each line creates one instance of the named reactor class.
  a = new Accelerometer()  // reads the hardware IMU
  t = new Tilt()           // computes pitch & roll from raw acceleration
  d = new Display()        // drives the robot LCD

  // ── TIMER ────────────────────────────────────────────────────────────────
  // Periodic timer: first fires at t=0 (startup), then every 100 ms.
  // 100 ms → 10 Hz sample rate, smooth enough to see tilt in real time.
  // Syntax: timer name(offset, period)
  timer sample(0, 100 msec)

  // ── REACTION 1: Kick the accelerometer every tick ─────────────────────────
  // This reaction fires whenever the "sample" timer triggers.
  // It sets the Accelerometer's boolean trigger input to true, causing
  // the Accelerometer's own reaction to run and read the hardware.
  //
  // lf_set(port, value) — LF primitive to write a value to an output port.
  reaction(sample) -> a.trigger {=
    lf_set(a.trigger, true);
  =}

  // ── CONNECTIONS: Accelerometer outputs → Tilt inputs ──────────────────────
  // These three lines are declarative wiring — no code needed.
  // Whenever the Accelerometer outputs x, y, z (after a trigger), those values
  // are automatically forwarded to the Tilt reactor's matching input ports.
  // Because both reactors run at the same logical time (same 100 ms tick),
  // the Tilt reaction fires in the same time step, right after Accelerometer.
  a.x -> t.x
  a.y -> t.y
  a.z -> t.z

  // ── REACTION 2: Format and display results ────────────────────────────────
  // This reaction fires when BOTH t.pitch/t.roll AND a.x/a.y are present.
  // In LF, listing multiple triggers with commas means "fire if ANY of these
  // are present". Because all four values arrive at the same logical time
  // (they're all produced in the same 100 ms tick), this fires once per tick.
  //
  // Outputs declared after "->" are the ports this reaction is allowed to write.
  reaction(t.pitch, t.roll, a.x, a.y) -> d.line0, d.line1, d.line2, d.line3 {=

    // Static buffers persist between calls without dynamic allocation.
    // 17 chars = 16 visible characters + null terminator.
    // The 8×16 font fits exactly 16 characters across the 128-pixel-wide display.
    static char buf0[17];
    static char buf1[17];
    static char buf2[17];
    static char buf3[17];

    // Format pitch angle. %+7.2f prints a sign-always, 7-char-wide float
    // with 2 decimal places: e.g., "+  12.34" or "- 123.45".
    // This keeps the display from shifting when the sign changes.
    snprintf(buf0, 17, "P:%+7.2f deg", t.pitch->value);

    // Format roll angle — same format as pitch.
    snprintf(buf1, 17, "R:%+7.2f deg", t.roll->value);

    // Raw X acceleration, 4 decimal places gives ~0.1 mg resolution display.
    // Example: "x:+0.9983 g"
    snprintf(buf2, 17, "x:%+.4f g", a.x->value);

    // Raw Y acceleration — same format.
    snprintf(buf3, 17, "y:%+.4f g", a.y->value);

    // Send each formatted string to the corresponding LCD line.
    // The Display reactor clears that line and redraws it each time.
    lf_set(d.line0, buf0);
    lf_set(d.line1, buf1);
    lf_set(d.line2, buf2);
    lf_set(d.line3, buf3);
  =}
}
